// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the MIT License.  See License.txt in the project root for license information.
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ReachingTypeAnalysis.Analysis;
using ReachingTypeAnalysis.Roslyn;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading.Tasks;

namespace ReachingTypeAnalysis
{

	/// <summary>
	/// This class is the base class for an analysis of Roslyn Methods
	/// Currenltly there are 2 subclasses: MethodSyntax and LibraryMethod
	/// </summary>
	internal class GeneralRoslynMethodProcessor
    {
        // Analysis representation
        public MethodInterfaceData MethodInterfaceData { get; set; }
        /// <summary>
        /// The next 3 properties are shortcuts for elements in MethodInterfaceData
        /// </summary>
        public AnalysisNode RetVar
        {
            get { return MethodInterfaceData.ReturnVariable; }
        }

        public IEnumerable<AnalysisNode> Parameters
        {
            get { return MethodInterfaceData.Parameters; }
        }

        public AnalysisNode ThisRef
        {
            get { return MethodInterfaceData.ThisRef; }
        }

        public StatementProcessor StatementProcessor { get; private set; }

        // Roslyn solution related
        public IMethodSymbol RoslynMethod { get; protected set; }
        // Communication
        public IDispatcher Dispatcher { get; private set; }
        //private AMethod analysisMethod;

        public AnalysisMethod AnalysisMethod { get; private set; }

        public GeneralRoslynMethodProcessor(IMethodSymbol roslynMethod, IDispatcher dispatcher)
        {
			Contract.Assert(roslynMethod != null);
			Contract.Assert(dispatcher != null);

			this.Dispatcher = dispatcher;
            this.RoslynMethod = roslynMethod;
            this.AnalysisMethod = new AnalysisMethod(roslynMethod);
            this.MethodInterfaceData = CreateMethodInterfaceData(roslynMethod);
            // The statement processor generates the Prpagagation Graph
            this.StatementProcessor = new StatementProcessor(
				this.AnalysisMethod.MethodDescriptor, 
				this.RetVar, this.ThisRef, this.Parameters);
        }

        /// <summary>
        /// This is the propagation graph generated by the 
        /// </summary>
        internal PropagationGraph PropGraph
        {
            get { return this.StatementProcessor.PropagationGraph; }
        }

        public IEnumerable<TypeDescriptor> InstantiatedTypes
        {
            get { return this.StatementProcessor.InstantiatedTypes; }
        }

		/// <summary>
		/// Generates analysis values for the method signature 
		/// In particular, the nodes for the propagation graph for parameters, retvalue y "this" 
		/// </summary>
		/// <param name="symbol"></param>
		/// <returns></returns>
		public MethodInterfaceData CreateMethodInterfaceData(IMethodSymbol symbol)
		{
			Contract.Assert(symbol != null);

			AnalysisNode retVar = null;
			AnalysisNode thisRef = null;
			IList<AnalysisNode> parameters;
			var inputs = new Dictionary<string, AnalysisNode>();
			var outputs = new Dictionary<string, AnalysisNode>();
			if (!symbol.ReturnsVoid && Utils.IsTypeForAnalysis(symbol.ReturnType))
			{
				retVar = new ReturnNode(new TypeDescriptor(symbol.ReturnType));
				outputs["retVar"] = retVar;
			}
			if (!symbol.IsStatic)
			{
				thisRef = new ThisNode(new TypeDescriptor(symbol.ReceiverType));
			}
			parameters = new List<AnalysisNode>();
			for (int i = 0; i < symbol.Parameters.Count(); i++)
			{
				var p = symbol.Parameters[i];
				var pNode = new ParameterNode(i, new TypeDescriptor(p.Type));
				parameters.Add(pNode);
				if (p.RefKind == RefKind.Ref || p.RefKind == RefKind.Out)
				{
					outputs[p.Name] = pNode;
				}
				inputs[p.Name] = pNode;
			}

			var methodInterfaceData = new MethodInterfaceData()
			{
				ReturnVariable = retVar,
				ThisRef = thisRef,
				Parameters = parameters,
				InputData = inputs,
				OutputData = outputs
			};
			return methodInterfaceData;
		}

        internal IDictionary<SyntaxNodeOrToken, AnalysisNode> expressionNodeCache = new Dictionary<SyntaxNodeOrToken, AnalysisNode>();
        //internal ANode CreateNodeForExpression(SyntaxNode ex)
        //{
        //    var type = semanticModel.GetTypeInfo(ex).Type;
        //    return CreateNodeForExpression(type, ex);
        //}
        //internal ANode CreateNodeForExpression(ITypeSymbol type, SyntaxNode ex)
        //{
        //    ANode node;
        //    if (!expressionNodeCache.TryGetValue(ex, out node))
        //    {
        //        ISymbol s = semanticModel.GetSymbolInfo(ex).Symbol;
        //        node = ANode.Define(type, ex, s);
        //        expressionNodeCache[ex] = node;
        //    }
        //    return node;
        //}
        //internal ANode CreateNodeForExpression(ITypeSymbol type, SyntaxNodeOrToken ex, ISymbol s)
        //{
        //    ANode node = null;
        //    if (Utils.IsTypeForAnalysis(type))
        //    {
        //        if (!expressionNodeCache.TryGetValue(ex, out node))
        //        {
        //            node = ANode.Define(type, ex, s);
        //            expressionNodeCache[ex] = node;
        //        }
        //    }
        //    return node;
        //}

        //private AnalysisNode CreateNodeForParameter(ITypeSymbol type, IParameterSymbol parameterSymbol,int i)
        //{
        //    var paramExp = SyntaxFactory.ParseExpression("parameter" + i);
        //    if (parameterSymbol != null)
        //    {
        //        paramExp = SyntaxFactory.IdentifierName(parameterSymbol.Name);
        //        /// parameterSymbol.DeclaringSyntaxReferences.First();
        //    }
			
        //    return new Parameter(type, paramExp, parameterSymbol);
        //}
    }

    /// <summary>
    /// This is the visitor for one method
    /// It creates an entity for the method that includes a statment procesor. 
    /// It models the propagation graph for the intraprocedural analysis
    /// </summary>
    internal class MethodSyntaxProcessor : GeneralRoslynMethodProcessor
    {
        private SyntaxNode methodNode;
		private CodeProvider codeProvider;

		public MethodSyntaxProcessor(IMethodSymbol method, CodeProvider provider, IDispatcher dispatcher)
            : base(method, dispatcher)
        {
            this.codeProvider = provider;
            this.methodNode = Utils.FindMethodDeclaration(method);

            // Ben: this is just a test to make the AST simpler. Disregard this :-)
            //method = MethodSimpifier.SimplifyASTForMethod(ref methodNode, ref semanticModel);
        }

        public MethodSyntaxProcessor(CodeProvider provider, MethodDescriptor method, IDispatcher dispatcher)
            : base(provider.FindMethodSyntaxAsync(method).Result.Item2, dispatcher)
        {
            this.codeProvider = provider;
            IMethodSymbol symbol;
            this.methodNode = provider.FindMethodSyntax(method, out symbol);

            // Ben: this is just a test to make the AST simpler. Disregard this :-)
            //method = MethodSimpifier.SimplifyASTForMethod(ref methodNode, ref semanticModel);
        }

        public IEntity ParseMethod()
        {
            Contract.Assert(methodNode != null);
            var propGraphGenerator = new MethodSyntaxVisitor(codeProvider, methodNode, this);
            propGraphGenerator.Visit(methodNode);

            var descriptor = EntityFactory.Create(this.AnalysisMethod);
            var methodEntity = EntityFactory.CreateEntity(
                                        new MethodEntity(propGraphGenerator.AnalysisMethod,
                                                                    propGraphGenerator.MethodInterfaceData,
                                                                    propGraphGenerator.PropGraph,
                                                                    propGraphGenerator.InstantiatedTypes), descriptor);
            this.Dispatcher.RegisterEntity(descriptor, methodEntity);
            return methodEntity;
        }
    }

    internal class MethodSyntaxVisitor : CSharpSyntaxVisitor<object>
    {
        protected IMethodSymbol roslynMethod;

        public AnalysisMethod AnalysisMethod { get; private set; }
        internal MethodInterfaceData MethodInterfaceData { get; private set; }

        internal AnalysisNode RetVar
        {
            get { return MethodInterfaceData.ReturnVariable; }
        }
        internal AnalysisNode ThisRef
        {
            get { return MethodInterfaceData.ThisRef; }
        }

        internal IEnumerable<AnalysisNode> Parameters
        {
            get { return MethodInterfaceData.Parameters; }
        }

        // var mw1 = new MethodWorker<Expr, Type, String>("m1", rv1, thisRefm1, paramsm1);
        //MethodWorker<ANode, AType, IMethodSymbol> worker;

        private CodeProvider codeProvider;
        private SyntaxNode methodNode;
        private ExpressionVisitor expressionsVisitor;
        private MethodSyntaxProcessor roslynMethodProcessor;

        internal StatementProcessor StatementProcessor
        {
            get { return this.roslynMethodProcessor.StatementProcessor; }
        }
        internal PropagationGraph PropGraph
        {
            get { return this.StatementProcessor.PropagationGraph; }
        }

        public IEnumerable<AnalysisType> InstantiatedTypes
        {
            get { return this.StatementProcessor.InstantiatedTypes; }
        }

        public MethodSyntaxVisitor(CodeProvider codeProvider, SyntaxNode methodSyntaxNode,
                            MethodSyntaxProcessor roslynMethodProcessor)
        {
            this.methodNode = methodSyntaxNode;
            this.codeProvider = codeProvider;
            //this.roslynMethod = roslynMethod;
            this.roslynMethodProcessor = roslynMethodProcessor;

            this.MethodInterfaceData = roslynMethodProcessor.MethodInterfaceData;
            this.AnalysisMethod = roslynMethodProcessor.AnalysisMethod;

            this.expressionsVisitor = new ExpressionVisitor(codeProvider, this.StatementProcessor, this);
        }

		
		public override object VisitCompilationUnit(CompilationUnitSyntax node)
        {
            foreach (var member in node.Members)
            {
                this.Visit(member);
            }
            return null;
        }

        public override object VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            Visit(node.Body);
            return null;
        }

        public override object VisitForEachStatement(ForEachStatementSyntax node)
        {
            var symbol = codeProvider.SemanticModel.GetDeclaredSymbol(node);
            var type = symbol.Type;

            // This is the declaration of the iterarion variable
            var lhs = new Identifier(node.Identifier, type, symbol);
            var rhs = expressionsVisitor.Visit(node.Expression);
            this.RegisterAssignment(lhs, rhs);

            // This is the body of the ForEach
            Visit(node.Statement);

            return null;
            //return base.VisitForEachStatement(node);
        }

        public override object DefaultVisit(SyntaxNode node)
        {
            return base.DefaultVisit(node);
        }

        #region Statements
        public override object VisitBlock(BlockSyntax node)
        {
            foreach (var st in node.Statements)
            {
                this.Visit(st);
            }
            return null;
        }

        public override object VisitSwitchStatement(SwitchStatementSyntax node)
        {
            expressionsVisitor.Visit(node.Expression);
            foreach (var section in node.Sections)
            {
                Visit(section);
            }
            return null;
        }

        public override object VisitSwitchSection(SwitchSectionSyntax node)
        {
            foreach (var statement in node.Statements)
            {
                Visit(statement);
            }

            return null;
        }

        public override object VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
        {
            AnalyzeDeclaration(node.Declaration);
            return null;
        }
        /// <summary>
        /// This method analyze a set of local variable declarations, i.e. C c = expression, D d = exp2,...;
        /// </summary>
        /// <param name="decl"></param>
        private void AnalyzeDeclaration(VariableDeclarationSyntax decl)
        {
            foreach (var v in decl.Variables)
            {
				var declaredVariableSymbol = (ILocalSymbol)codeProvider.SemanticModel.GetDeclaredSymbol(v);
                // Register the variable in the PropGraph
                // Note it returns a Node, not an analysis expression
                var lhsAnalysisNode = RegisterVariable(v.Identifier, declaredVariableSymbol);

                if (v.Initializer != null)
                {
                    // This is the rhs of the assigment
                    // We first visit the expression because it may conatain invocations
                    var rhsAnalysisExpression = expressionsVisitor.Visit(v.Initializer.Value);
                    if (rhsAnalysisExpression != null)
                    {
                        rhsAnalysisExpression.ProcessAssignment(lhsAnalysisNode, this);
                    }
                }
            }
        }

        public override object VisitElseClause(ElseClauseSyntax node)
        {
            return Visit(node.Statement);
        }
        public override object VisitIfStatement(IfStatementSyntax node)
        {
            expressionsVisitor.Visit(node.Condition);

            Visit(node.Statement);
            Visit(node.Else);

            return null;
        }
        /// <summary>
        /// INCOMPLETE!
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public override object VisitForStatement(ForStatementSyntax node)
        {
            // Should do the same as LocalDeclarations
            AnalyzeDeclaration(node.Declaration);
            Visit(node.Statement);

			if (node.Condition != null)
			{
				expressionsVisitor.Visit(node.Condition);
			}

			foreach (var inc in node.Incrementors)
			{
				expressionsVisitor.Visit(inc);
			}

            return null;
        }
        public override object VisitExpressionStatement(ExpressionStatementSyntax node)
        {
            expressionsVisitor.Visit(node.Expression);

            return null;
        }

        public override object VisitReturnStatement(ReturnStatementSyntax node)
        {
            var returnValueAnalysisExpression = expressionsVisitor.Visit(node.Expression);
            if (this.RetVar != null && returnValueAnalysisExpression != null)
            {
                returnValueAnalysisExpression.ProcessAssignment(this.RetVar, this);
            }
            return null;
        }
        #endregion

        public override object VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            VisitBlock(node.Body);
            return null;
        }

        public override object VisitDestructorDeclaration(DestructorDeclarationSyntax node)
        {
            VisitBlock(node.Body);
            return null;
        }

        public override object VisitAccessorDeclaration(AccessorDeclarationSyntax node)
        {
            if (node.Body != null)
            {
                VisitBlock(node.Body);
            }
            return null;
        }

        public override object VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
        {
            VisitBlock(node.Body);
            return null;
        }

        public override object VisitOperatorDeclaration(OperatorDeclarationSyntax node)
        {
            VisitBlock(node.Body);
            return null;
        }

        #region Helpers to connect with statement processor
        internal AnalysisNode RegisterVariable(ExpressionSyntax v)
        {
            var tVar = codeProvider.SemanticModel.GetTypeInfo(v);
            var s = codeProvider.SemanticModel.GetSymbolInfo(v).Symbol;
            var lhs = RegisterVariable(v, tVar.Type, s);
            //var lhs = RegisterVariable(v, tVar.Type,s);
            return lhs;
        }

        internal AnalysisNode RegisterVariable(SyntaxNodeOrToken v, ILocalSymbol s)
        {
            return RegisterVariable(v, s.Type, s);
        }

        internal AnalysisNode RegisterVariable(SyntaxNodeOrToken v, ITypeSymbol type, ISymbol s)
        {

            AnalysisNode lhs;
            if (type.TypeKind.Equals(TypeKind.Delegate))
            {
				lhs = new DelegateNode(new TypeDescriptor(type), v.ToString());
            }
            else
            {
                lhs = CreateNodeForExpression(type, v, s);
                //lhs = ANode.Define(t, v);
            }
            if (lhs != null) this.StatementProcessor.RegisterLocalVariable(lhs);
            return lhs;
        }

        internal void RegisterAssignment(AnalysisExpression lhs, AnalysisExpression rhs)
        {
            Contract.Assert(lhs is Field || lhs is Identifier);
            if (lhs != null)
            {
                this.RegisterAssignment(lhs.GetAnalysisNode(), rhs);
            }
        }

        internal void RegisterAssignment(AnalysisNode lhsNode, AnalysisExpression rhs)
        {
            if (lhsNode != null && rhs != null && Utils.IsTypeForAnalysis(rhs.GetAnalysisType()))
            {
                this.StatementProcessor.RegisterAssignment(lhsNode, rhs.GetAnalysisNode());
            }
        }

        internal void RegisterNewExpressionAssignment(AnalysisNode lhsNode, AnalysisType aType)
        {
            this.StatementProcessor.RegisterNewExpressionAssignment(lhsNode, aType);
        }

        internal void RegisterCallLHS(AnalysisNode lhsNode, AnalysisExpression rhsExpression)
        {
            var callNode = rhsExpression.GetAnalysisNode() as AnalysisCallNode;
            this.StatementProcessor.RegisterCallLHS(callNode, lhsNode);
        }

        internal void RegisterDelegate(AnalysisNode lhsNode, IMethodSymbol delegateMethod)
        {
            this.StatementProcessor.RegisterDelegateAssignment(lhsNode, new AnalysisMethod(delegateMethod));
        }

        //public ANode RegisterExpression(ExpressionSyntax lhs)
        //{
        //    // We use the declared typed for Nodes abstraction
        //    var declaredTypeLHS = semanticModel.GetTypeInfo(lhs).Type;

        //    //var node = new MyNodes(declaredTypeLHS,lhs.GetLocation());
        //    var node = ANode.Define(declaredTypeLHS, lhs);
        //    if(node!=null) statementProcessor.RegisterLocalVar(node);
        //    return node;
        //}

        internal IDictionary<SyntaxNodeOrToken, AnalysisNode> expressionNodeCache = new Dictionary<SyntaxNodeOrToken, AnalysisNode>();
        internal AnalysisNode CreateNodeForExpression(SyntaxNode ex)
        {
            var type = codeProvider.SemanticModel.GetTypeInfo(ex).Type;
            return CreateNodeForExpression(type, ex);
        }
        internal AnalysisNode CreateNodeForExpression(ITypeSymbol type, SyntaxNode ex)
        {
            AnalysisNode node;
            if (!expressionNodeCache.TryGetValue(ex, out node))
            {
                ISymbol s = codeProvider.SemanticModel.GetSymbolInfo(ex).Symbol;
                node = AnalysisNode.Define(type, ex, s);
                expressionNodeCache[ex] = node;
            }
            return node;
        }
        internal AnalysisNode CreateNodeForExpression(ITypeSymbol type, SyntaxNodeOrToken ex, ISymbol s)
        {
            AnalysisNode node = null;
            if (Utils.IsTypeForAnalysis(type))
            {
                if (!expressionNodeCache.TryGetValue(ex, out node))
                {
                    node = AnalysisNode.Define(type, ex, s);
                    expressionNodeCache[ex] = node;
                }
            }
            return node;
        }

        #endregion
    }

	/// <summary>
	/// This is use to traverse a complete project and create a processor for each one.
	/// Another way is to do it on demand. I'm trying both options.
	/// </summary>
	internal class AllMethodsVisitor : CSharpSyntaxWalker
    {
        private IDispatcher dispatcher;
		private CodeProvider codeProvider;

		internal AllMethodsVisitor(CodeProvider codeProvider, IDispatcher dispatcher)
        {
            this.codeProvider = codeProvider;
            this.dispatcher = dispatcher;
        }

        public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            var method = this.codeProvider.SemanticModel.GetDeclaredSymbol(node);
            var processor = new MethodSyntaxProcessor(method, this.codeProvider, dispatcher);
            processor.ParseMethod();
        }

        public override void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            var method = this.codeProvider.SemanticModel.GetDeclaredSymbol(node);
			var processor = new MethodSyntaxProcessor(method, this.codeProvider, dispatcher);
            processor.ParseMethod();
        }

		internal async Task Run()
		{
			var root = await this.codeProvider.SyntaxTree.GetRootAsync();

			this.Visit(root);
		}
    }

	internal class MethodFinder : CSharpSyntaxWalker
	{
		private MethodDescriptor MethodDescriptor;
		private SemanticModel SemanticModel;
		internal BaseMethodDeclarationSyntax Result { get; private set; }

		internal MethodFinder(MethodDescriptor descriptor, SemanticModel semanticModel)
		{
			this.MethodDescriptor = descriptor;
			this.SemanticModel = semanticModel;
		}

		internal MethodFinder(IMethodSymbol symbol, SemanticModel semanticModel)
		{
			Contract.Assert(symbol != null);
			Contract.Assert(semanticModel != null);

			this.MethodDescriptor = new MethodDescriptor(symbol);
			this.SemanticModel = semanticModel;
		}
		//public override object VisitCompilationUnit(CompilationUnitSyntax node)
		//{
		//    foreach (var member in node.Members)
		//    {
		//        Visit(member);
		//    }
		//    return null;
		//}
		//public override object VisitClassDeclaration(ClassDeclarationSyntax node)
		//{
		//    foreach (var member in node.Members)
		//    {
		//        Visit(member);
		//    }

		//    return null;
		//}

		public override void Visit(SyntaxNode syntax)
		{
			var kind = syntax.Kind();
            switch (kind)
			{
				case SyntaxKind.MethodDeclaration:
					{
						var node = (MethodDeclarationSyntax)syntax;
						var symbol = this.SemanticModel.GetDeclaredSymbol(node);
						var thisDescriptor = new MethodDescriptor(symbol);
						if (thisDescriptor.Equals(this.MethodDescriptor))
						{
							// found it!
							this.Result = node;
						}
						break;
					}
				case SyntaxKind.ConstructorDeclaration:
					{
						var node = (ConstructorDeclarationSyntax)syntax;
						var symbol = this.SemanticModel.GetDeclaredSymbol(node);
						var thisDescriptor = new MethodDescriptor(symbol);
						if (thisDescriptor.Equals(this.MethodDescriptor))
						{
							// found it!
							this.Result = node;
						}
						break;
					}
			}

			base.Visit(syntax);
		}	
	}
}